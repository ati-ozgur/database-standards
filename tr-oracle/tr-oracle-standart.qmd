# Karkas Oracle veri tabanı standartları

## Kurulum Notları Collation

Oracle veritabanı kurulurken, character set olarak AL32UTF8 seçilmelidir.
[Choosing Unicode as a Database Character Set in Globalization Support Guide](https://docs.oracle.com/en/database/oracle/oracle-database/12.2/nlspg/choosing-character-set.html) dokumanında oracle, her yeni veritabanı için unicode kullanılmasını tavsiye ediyor.

> Oracle recommends using Unicode for all new system deployments. Migrating legacy systems to Unicode is also recommended. Deploying your systems today in Unicode offers many advantages in usability, compatibility, and extensibility. 



{{< include ./sema.md >}}

{{< include ./isimlendirme.md >}}


## Kolon Veri Yapıları

### Primary Key

Birincil anahtar (Primary Key) konulmayan tablo olmayacaktır.
Primary key değerleri olarak guid veya identity seçilmeli proje boyunca benzer bir yapı kullanılmalıdır.
Yeni oracle versiyonları, identity kolonlarını desteklemektedir.


Primary key Sentetik Anahtar (Surrogate Key) olarak int IDENTITY değerleri yerine guid tercih edilmesi, kod yazılması kolaylığı açısından değerlendirilmeli ve proje başlangıcında karar verilmelidir.
Eğer guid PK olarak kullanılıyorsa default değer olarak SYS_GUID() olmalıdır.

```sql
CREATE TABLE TEST ( TEST_KEY RAW(16) default SYS_GUID() ) 

```





### Foreign Key

Eğer bir tablo içindeki kolon başka bir tabloya referans veriyorsa kesinlikle yabancı anahtar (foreign key) tanımlanmalıdır.
Bu yabancı anahtar kolonun ismi TabloIsmiTurNo yada TabloIsmiKey olarak tanımlanmalıdır.
Tanım tabloları için TurNo kullanılmalıdır.
Normal modül tabloları için Key kullanılmalıdır.
TurNo yerine referans verilen tanımın türkçesine göre TipNo gibi diğer kelimelerde kullanılabilir.
Eğer bir kolon ismi TurNo, TipNo, Turu, Tipi, RenkNo, BilgiNo gibi bir kelime ile bitiyorsa ise Tanım Tablolarına referans veriliyordur.
TurNo(...) okunduğu zaman bir tanım tablosuna referans düşünülürken, Key ise 1..* veya 1..1 ilişkisini ana modül tablolarına tanımlamalıdır.

### Yazı Değerler (varchar...)

Yazı değerleri eğer değişken ise varchar ile, eğer sabit bir değer ise char olarak tutulmalıdır. 
Örneğin:

- Eğer bilgi girilen tip daima aynı sayıda ise örnek: Posta Kodu gibi char olarak tanımlanmalıdır.
- Eğer bilgi girilen değer değişken bir değer ise, ad soyad gibi varchar olarak tanımlanmalıdır.

Eğer veri tabanında kullanılan genel dilden (türkçe olmayan) farklı değer girilebilir ise nchar,nvarchar tanımlanmalıdır.

### Sayı Değerler

Sayı değerleri için alabilecekleri aralıkları düşünerek tiny int, short int , int veya big int kullanınız. 

-   Tablodaki değer  -32,768 - 32,767   smallint veri yapısını kullanın.
-   eğer tamsayı değer  -2,147,483,648 - 2,147,483,647 arası ise int veri yapısını kullanın.

### Para ve Ondalık Değerler

-  Money SQL standartında yoktur. Kullanılmamalıdır. 
-  Float ve double tam değerler değildir, yaklaşık değer olarak çalışırlar. 
Para hesaplarında kesinlikle kullanılmamaları gerekir.

- numeric ve  decimal aynı veri tipidir.
Bir birlerinin diğer ismi (alias) olarak tanımlıdırlar. 

- Eğer para değerlerinde daha fazla küsürata ihtiyaç var ise  numeric(18,4)-decimal(18,4) gibi artırılabilir. 

### Tarih Değerleri

Tarih değerleri 	

|Tarih Veri tipi |doğruluk (accuracy)|  Başlangıç Tarihi | Bitiş Tarihi  |
|---|---|---|---|
|datetime|3.33 milliseconds accuracy   | Jan 1, 1753  | Dec 31, 9999  |
|smalldatetime| 1 minute accuracy  | Jan 1, 1900  | Jun 6, 2079  |

TODO: daha sonra türkçe yap

değerleri arasını göstermektedir. 

.NET üstünde doğru kabul edilen,  örn: 01.01.1600 gibi bir değer SQL Server üzerinde hata verebilir.
Tarih değerlerinin bu aralıkta olduğuna emin olunuz.

- Tarih bilgilerini tutarken smalldatetime tercih ediniz. 			
- Eğer sadece yıl bilgisi tutacaksanız, Mezuniyet yılı smallint tutabilirsiniz. 

```sql
 CHECK  (([GirisSene]>=(1900) AND   [GirisSene]<=datepart(year,getdate()))) 
```
Yukarıdakı kısıtlama giris senesinin 1900 ile şu an bulunduğumuz sene arasında kalmasını sağlamaktadır.


### Resim Dosya gibi Binary Değerler

Resim veya binary data tutmak için varbinary(max) tercih edin. 
Veri tipi image SQL Server'ın yeni versiyonlarında kullanılmayacaktır.
 
### Diger Notlar


-   Tablolarda mümkün olduğunca girilen bilgiler not null yapılmalıdır.
-   Eğer anlamlı bir default/varsayılan değer verilebiliyorsa verilmelidir. 
- Örneğin GuncellemeTarih default now() verilebilir.


  
## Yazılım Geliştirme Yetkileri

Yazılım geliştiriciler için sınırlı yetkili veri tabanı kullanıcılar açılması ve SQL Sever Management Studio üzerinde işlem yapılırken bu  kullanıcılar ile sisteme girilmesi.düşünülmelidir.
En doğrusu yazılım geliştirici kullanıcılarının bir role atanması ve bu rolün kısıtlanması olabilir.

  	 
## Stored Procedures - Functions

Yazılım geliştiriciler Stored Procedure yazma gereksinimi duyarlarsa bunu veritabanı yöneticisi ve takım liderlerinin onayını	aldıktan sonra yapabileceklerdir.
Veri tabanında mümkün olduğunca stored procedure ve trigger olmamalı, bunların yerine .NET kodları ile çözüm bulunmaya çalışılmalıdır.

Stored procedure, function ve trigger'lar için macar notasyonu kullanıp kullanılmayacağına başta karar verilmelidir.
Yazılım geliştirme araçlarının daha gelişmiş olması sebebi ile artık macar notasyonuna olan ihtiyaç azalmıştır.
Ama eğer macar notasyonu kullanıyorsanız: 
Stored Procudures usp_ ile, functionlar ufn_ ile, triggerler ise utnX_ ile başlamalıdır (X-->;i:insert, u:update, d:delete).

Note: eğer bir stored Procedure sp veya xp ile başlarsa SQL server bunun System stored procedure'u olduğunu düşündüğü için ilk önce master veritabanında arayacaktır. 
  
  
## İsimlendirme Konvansiyonu
  
### İsimlendirme Konvansiyonu - Stored Procedure - Gömülü Yordamlar

Stored Procudure'lara isim verirken modül/ ana tablo ismi + yaptığı işlem şeklinde isim verin.
    
- Modül Ismi + yaptığı iş 
- PersonelAraAdiVeSoyadiIle 
- Personel_Oku_Tum 
- MuhasebeYillikMizanHesapla
- BordroAylikBordroHesapla


Not bu isimler örnek olsun diye verilmiştir. 
Veritabanında basit CRUD ve arama işlemleri için stored procedure olmamalıdır.

### İsimlendirme Konvansiyonu - Table and View-Tablo ve Görüntü


- INSAN_KAYNAKLARI.MUSTERI 
- TANIM_TABLOLARI.NUFUS_CUZDANI_VERILIS_NEDENI



Tablo ve görüntülere (view) ayrı isimler vermiyoruz.
Bunun nedeni ihtiyaça göre tablo veya görüntünün değiştirilebilmesine izin vermektir.
Örneğin çok kullanılan bir view, tablo yapılabilir.
Yada bilgiler daha farklı tutulduğu için eski bir tablo, view yapılabilir.
Bu tür durumlarda isim aynı kaldığı için istemci programları sorunsuz çalışacaktır.


### İsimlendirme Konvansiyonu - Column-Kolon

Her kelimenin ilk harfi büyük yazılır. 

- MusteriKey 
- SonDegistirmeTarihi
- TipNo
- MusteriKey


### İsimlendirme Konvansiyonu - Index

IX_TabloIsmi_KolonIsimleri  veya UQ_TabloIsmi_KolonIsimleri şeklinde kullanılmalıdır.
Her kelimenin ilk harfi büyük yazılır.
Unique indexler UQ ile başlarken, diğer indexler IX ile başlamalıdır.

 
- IX_Musteri_MusteriNo
- IX_Satislar_TipNo
- IX_Satislar_MusteriKey
- UQ_Musteri_VergiNo

### İsimlendirme Konvansiyonu - Yabancı anahtar (Foreign key)

- FK_TabloIsmi1KolonIsmi1FK_TabloIsmi2KolonIsmi2 
- FK_MusteriMusteriNoSiparisMusteriNo

Her kelimenin ilk harfi büyük yazılır. 


### İsimlendirme Konvansiyonu - Default - Varsayılan

- DF_
- DF_PERSONEL_IlkGirisTarihi 


SQL Server DF veriyor.
Management Studio icinde Default'ları verirseniz, İsimlendirme düzgün olur. 

### İsimlendirme Konvansiyonu - Constraint 

- CK_
- CK_OKUL_BILGILERI_GirisSenesi  

  

SQL Server CK veriyor. 
Management Studio icinde Constarint yazarsanız, İsimlendirme düzgün olur.
  
### İsimlendirme Konvansiyonu - Trigger - Tetikleyici  

utrX + Tablo Ismi, yerine triggerin hangi işlem için olduğunu söyleyen bir kelime gelicektir. 

- utrX_ + tablo ismi + islem (insert (i), update (u), delete (d))
- utrX_ORTAK_KISI_Delete
  

{{< include ./application-user.md >}}

{{< include ./duzenleme-gecmis.md >}}

